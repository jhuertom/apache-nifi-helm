{{- $serviceHostName := printf "%s-http.%s" (include "nifi.fullname" . ) .Release.Namespace }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" . }}
  labels:
    {{- include "nifi.labels" . | nindent 4 }}
data:
  custom-startup.sh: |
    #!/bin/bash -e

    prop_add () {
      target_file="${3:-${nifi_props_file}}"
      echo "adding property to target file ${target_file}"
      echo "$1=$2" >> "${target_file}"
    }

    prop_remove () {
      target_file="${3:-${nifi_props_file}}"
      echo "removing property from target file ${target_file}"
      sed -i -e "s|^$1=.*$||" "${target_file}"
    }

    authorizers_file='conf/authorizers.xml'
    bootstrap_file='conf/bootstrap.conf'
    nifi_properties_file='conf/nifi.properties'
    logback_file='conf/logback.xml'
    scripts_dir='/opt/nifi/scripts'
    [ -f "${scripts_dir}/common.sh" ] && . "${scripts_dir}/common.sh"

    {{- /* Set host connection properties so the node is reachable, with TLS hostname verification */}}
    host_name="${HOSTNAME}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
    pod_index=$(echo ${HOSTNAME} | sed -E 's/^.*([0-9]+)$/\1/g')

    prop_replace 'nifi.web.https.host' "${host_name}"
    export NIFI_WEB_HTTPS_HOST="${host_name}"
    export NIFI_WEB_PROXY_HOST=" \
      ${host_name}, \
      {{ .Values.ingress.hostName }}, \
      {{ include "nifi.siteToSiteHostName" . }}, \
      {{ include "nifi.siteToSiteHostName" . }}:443, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}:443, \
      {{ $serviceHostName }}, \
      {{ $serviceHostName }}:{{ .Values.ports.https }}"

    {{- /* S2S cluster-local connections */}}
    export NIFI_REMOTE_INPUT_HOST="${HOSTNAME}"
    prop_add 'nifi.remote.route.raw.cluster.when' '${s2s.source.hostname:equals('\''{{ $serviceHostName }}'\'')}'
    prop_add 'nifi.remote.route.raw.cluster.hostname' '${s2s.target.hostname}'
    prop_add 'nifi.remote.route.raw.cluster.port' {{ .Values.ports.remoteinput | squote }}
    prop_add 'nifi.remote.route.raw.cluster.secure' 'true'

    {{- /* S2S connections via Ingress */}}
    prop_add 'nifi.remote.route.http.ingress.when' '${X-ProxyHost:contains('\''{{ include "nifi.siteToSiteHostName" . }}'\'')}'
    prop_add 'nifi.remote.route.http.ingress.hostname' '${s2s.target.hostname}.{{ include "nifi.siteToSiteHostName" . }}'
    prop_add 'nifi.remote.route.http.ingress.port' '443'
    prop_add 'nifi.remote.route.http.ingress.secure' 'true'

    {{- /* Configure authentication method based on priority: OIDC > LDAP > Basic */}}
    {{- if .Values.global.oidc.enabled }}
    echo "Enabling OIDC authentication"
    prop_replace 'nifi.security.user.oidc.discovery.url' '{{ .Values.global.oidc.oidc_url }}'
    prop_replace 'nifi.security.user.oidc.client.id' '{{ .Values.global.oidc.client_id }}'
    prop_replace 'nifi.security.user.oidc.claim.identifying.user' '{{ .Values.global.oidc.claim_identifying_user }}'
    {{- else if .Values.global.ldap.enabled }}
    echo "Enabling LDAP user authentication"
    # Disable Single User provider completely
    export SINGLE_USER_CREDENTIALS_USERNAME=""
    export SINGLE_USER_CREDENTIALS_PASSWORD=""
    
    # CRITICAL: Create a clean login-identity-providers.xml with only ldap-provider
    # The original file has commented sections that cause duplicate provider issues
    echo "Creating clean login-identity-providers.xml for LDAP..."
    
    # Build the XML file using printf to avoid YAML parsing issues
    LOGIN_PROVIDERS_FILE='conf/login-identity-providers.xml'
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' > "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '<loginIdentityProviders>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '    <provider>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <identifier>ldap-provider</identifier>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.ldap.LdapProvider</class>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Authentication Strategy">{{ .Values.global.ldap.authenticationStrategy }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Manager DN">{{ .Values.global.ldap.manager.distinguishedName }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' "        <property name=\"Manager Password\">${LDAP_MANAGER_PASSWORD}</property>" >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Password"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Type"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Password"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Type"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Client Auth"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Protocol">{{ .Values.global.ldap.tlsProtocol }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Shutdown Gracefully"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Referral Strategy">FOLLOW</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Connect Timeout">10 secs</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Read Timeout">10 secs</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Url">{{ .Values.global.ldap.url }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="User Search Base">{{ .Values.global.ldap.userSearchBase }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="User Search Filter">{{ .Values.global.ldap.userSearchFilter }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Identity Strategy">{{ .Values.global.ldap.identityStrategy }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Authentication Expiration">12 hours</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '    </provider>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '</loginIdentityProviders>' >> "$LOGIN_PROVIDERS_FILE"
    
    {{- if or (eq .Values.global.ldap.authenticationStrategy "LDAPS") (eq .Values.global.ldap.authenticationStrategy "START_TLS") }}
    # Configure TLS settings for secure LDAP
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore']" \
      --value "${LDAP_TLS_KEYSTORE}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore Password']" \
      --value "${LDAP_TLS_KEYSTORE_PASSWORD}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore Type']" \
      --value "PKCS12" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore']" \
      --value "${LDAP_TLS_TRUSTSTORE}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore Password']" \
      --value "${LDAP_TLS_TRUSTSTORE_PASSWORD}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore Type']" \
      --value "PKCS12" \
      'conf/login-identity-providers.xml'
    {{- end }}
    
    echo "login-identity-providers.xml configured successfully."
    
    # Set the authorizer and login identity provider
    prop_replace 'nifi.security.user.authorizer' 'managed-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'ldap-provider'
    
    # CRITICAL: Create a clean authorizers.xml with ONLY LDAP (no single-user-authorizer)
    # This prevents NiFi from loading the single-user-authorizer at all
    echo "Creating clean authorizers.xml for LDAP-only authentication..."
    
    AUTHORIZERS_FILE='conf/authorizers.xml'
    
    # Build authorizers.xml using printf to avoid YAML parsing issues with XML declarations
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' > "$AUTHORIZERS_FILE"
    printf '%s\n' '<authorizers>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    <userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <identifier>file-user-group-provider</identifier>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.authorization.FileUserGroupProvider</class>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Users File">./persistent_conf/users.xml</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Initial User Identity 1">{{ .Values.global.ldap.initialAdminIdentity }}</property>' >> "$AUTHORIZERS_FILE"
    # Add ingress identity (CN=nifi.nifi) for proxy authentication
    printf '%s\n' '        <property name="Initial User Identity 2">CN={{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}</property>' >> "$AUTHORIZERS_FILE"
    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
    printf '%s\n' '        <property name="Initial User Identity {{ add $i 3 }}">CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}</property>' >> "$AUTHORIZERS_FILE"
    {{- end }}
    printf '%s\n' '    </userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    <userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <identifier>ldap-user-group-provider</identifier>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.ldap.tenants.LdapUserGroupProvider</class>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Authentication Strategy">{{ .Values.global.ldap.authenticationStrategy }}</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Manager DN">{{ .Values.global.ldap.manager.distinguishedName }}</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' "        <property name=\"Manager Password\">\${LDAP_MANAGER_PASSWORD}</property>" >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Password"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Type"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Password"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Type"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Client Auth"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Protocol">TLSv1.2</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="TLS - Shutdown Gracefully"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Referral Strategy">FOLLOW</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Connect Timeout">10 secs</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Read Timeout">10 secs</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Url">{{ .Values.global.ldap.url }}</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Page Size"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Sync Interval">30 mins</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Membership - Enforce Case Sensitivity">false</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Search Base">{{ .Values.global.ldap.userSearchBase }}</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Object Class">person</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Search Scope">ONE_LEVEL</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Search Filter">{{ .Values.global.ldap.userSearchFilter }}</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Identity Attribute">uid</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Group Name Attribute"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Group Name Attribute - Referenced Group Attribute"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Search Base"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Object Class">group</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Search Scope">ONE_LEVEL</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Search Filter"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Name Attribute"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Member Attribute"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Group Member Attribute - Referenced User Attribute"></property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    </userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    <userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <identifier>composite-configurable-user-group-provider</identifier>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.authorization.CompositeConfigurableUserGroupProvider</class>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Configurable User Group Provider">file-user-group-provider</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Group Provider 1">ldap-user-group-provider</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    </userGroupProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    <accessPolicyProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <identifier>file-access-policy-provider</identifier>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.authorization.FileAccessPolicyProvider</class>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="User Group Provider">composite-configurable-user-group-provider</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Authorizations File">./persistent_conf/authorizations.xml</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Initial Admin Identity">{{ .Values.global.ldap.initialAdminIdentity }}</property>' >> "$AUTHORIZERS_FILE"
    # Add ingress as Node Identity for proxy permissions
    printf '%s\n' '        <property name="Node Identity 1">CN={{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}</property>' >> "$AUTHORIZERS_FILE"
    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
    printf '%s\n' '        <property name="Node Identity {{ add $i 2 }}">CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}</property>' >> "$AUTHORIZERS_FILE"
    {{- end }}
    printf '%s\n' '    </accessPolicyProvider>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    <authorizer>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <identifier>managed-authorizer</identifier>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.authorization.StandardManagedAuthorizer</class>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '        <property name="Access Policy Provider">file-access-policy-provider</property>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '    </authorizer>' >> "$AUTHORIZERS_FILE"
    printf '%s\n' '</authorizers>' >> "$AUTHORIZERS_FILE"
    
    # Replace the password placeholder with actual value
    sed -i "s|\${LDAP_MANAGER_PASSWORD}|${LDAP_MANAGER_PASSWORD}|g" "$AUTHORIZERS_FILE"
    
    echo "authorizers.xml created with LDAP-only configuration (no single-user-authorizer)."
    echo "LDAP authentication configured."
    
    {{- else }}
    echo "Enabling Single User (Basic) authentication"
    prop_replace 'nifi.security.user.authorizer' 'single-user-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'single-user-provider'
    {{- end }}

    {{- /* Replace properties not exposed by environment variables */}}
    {{- if eq (include "nifi.useZooKeeper" .) "true" }}
    prop_replace 'nifi.zookeeper.client.secure' 'false'
    {{- else }}
    prop_replace 'nifi.state.management.provider.cluster' 'kubernetes-provider'
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Name Prefix']" --value '{{ .Values.stateManagement.kubernetes.statePrefix }}' "conf/state-management.xml"
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Namespace']" --value '{{ include "nifi.stateManagementNamespace" . }}' "conf/state-management.xml"
    {{- end }}

    # Absolute paths for persistence
    PERSISTENT_CONF_DIR='/opt/nifi/nifi-current/persistent_conf'
    USERS_XML="${PERSISTENT_CONF_DIR}/users.xml"
    AUTH_XML="${PERSISTENT_CONF_DIR}/authorizations.xml"
    FLOW_FILE="${PERSISTENT_CONF_DIR}/flow.json.gz"

    # Ensure persistent conf directory exists
    mkdir -p "$PERSISTENT_CONF_DIR"

    {{- if .Values.global.ldap.enabled }}
    # LDAP MODE: Let NiFi create users.xml and authorizations.xml automatically
    # The Initial Admin Identity in authorizers.xml will be used to bootstrap permissions
    # DO NOT create these files manually - it prevents NiFi from applying Initial Admin Identity
    
    echo "LDAP mode: Letting NiFi auto-provision authorization files with Initial Admin Identity: {{ .Values.global.ldap.initialAdminIdentity }}"
    
    # Remove any existing authorization files to force NiFi to recreate them
    # This ensures Initial Admin Identity is properly applied
    if [ -f "$USERS_XML" ] || [ -f "$AUTH_XML" ]; then
        echo "WARNING: Existing authorization files found. Removing to allow NiFi to apply Initial Admin Identity..."
        rm -f "$USERS_XML" "$AUTH_XML"
    fi
    {{- else }}
    # Deterministic UUID Generator (NiFi-aligned Version 3 UUID) - needed for non-LDAP mode
    GET_UUID() {
      python3 -c "import uuid, hashlib; md5 = hashlib.md5('$1'.encode('utf-8')).digest(); uid = list(md5); uid[6] = (uid[6] & 0x0f) | 0x30; uid[8] = (uid[8] & 0x3f) | 0x80; print(str(uuid.UUID(bytes=bytes(uid))))"
    }
    
    # Non-LDAP mode: Create users.xml and authorizations.xml manually
    if [ ! -f "$USERS_XML" ]; then
        echo "Provisioning initial security registry..."
        mkdir -p "$PERSISTENT_CONF_DIR"

        # BUILD IDENTITIES LIST
        ADMIN_IDENTITIES=""
        # NiFi Nodes
        for (( i = 0; i < {{ .Values.global.nifi.nodeCount }}; i++ )); do
            ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}-${i}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        done
        # Ingress Node
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        # LDAP Admin
        {{- if and .Values.global.ldap.enabled .Values.global.ldap.initialAdminIdentity }}
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} {{ .Values.global.ldap.initialAdminIdentity }}"
        {{- end }}

        echo "Identities to authorize:$ADMIN_IDENTITIES"

        # 1. Generate users.xml
        # We'll create a group called 'NiFi Administrators' and add everyone to it.
        # CRITICAL: In NiFi 2.x, <groups> MUST come BEFORE <users> in the <tenants> element.
        GROUP_NAME="NiFi Administrators"
        GROUP_ID=$(GET_UUID "group-$GROUP_NAME")

        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$USERS_XML"
        echo '<tenants>' >> "$USERS_XML"
        echo '  <groups>' >> "$USERS_XML"
        echo "    <group identifier=\"$GROUP_ID\" name=\"$GROUP_NAME\">" >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "      <user identifier=\"$U_ID\"/>" >> "$USERS_XML"
        done
        echo '    </group>' >> "$USERS_XML"
        echo '  </groups>' >> "$USERS_XML"
        echo '  <users>' >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "    <user identifier=\"$U_ID\" identity=\"$DN\"/>" >> "$USERS_XML"
        done
        echo '  </users>' >> "$USERS_XML"
        echo '</tenants>' >> "$USERS_XML"

        # 2. Generate authorizations.xml
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$AUTH_XML"
        echo '<authorizations>' >> "$AUTH_XML"
        echo '  <policies>' >> "$AUTH_XML"
        
        RESOURCES="/flow /controller /proxy /restricted-components /tenants /policies"
        
        # Access Root Group - Get ROOT_ID from existing flow or wait for it
        ROOT_ID=""
        if [ -s "$FLOW_FILE" ]; then
            ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        fi
        
        # If no flow exists yet, we'll add root group policies after NiFi creates the flow
        # For now, add a placeholder that will be updated on subsequent restarts
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            echo "Found existing ROOT_ID: $ROOT_ID"
            RESOURCES="$RESOURCES /process-groups/$ROOT_ID /data/process-groups/$ROOT_ID /operation/process-groups/$ROOT_ID"
        else
            echo "No flow.json.gz found yet. Root group policies will be added after first NiFi startup."
        fi

        for RES in $RESOURCES; do
            for ACT in R W; do
                P_ID=$(GET_UUID "policy-$RES-$ACT")
                echo "    <policy action=\"$ACT\" identifier=\"$P_ID\" resource=\"$RES\">" >> "$AUTH_XML"
                echo "      <group identifier=\"$GROUP_ID\"/>" >> "$AUTH_XML"
                echo "    </policy>" >> "$AUTH_XML"
            done
        done
        echo '  </policies>' >> "$AUTH_XML"
        echo '</authorizations>' >> "$AUTH_XML"
        echo "Security registry provisioned successfully."
    fi
    {{- end }}

    {{- if not .Values.global.ldap.enabled }}
    # UPDATE ROOT GROUP POLICIES if flow.json.gz exists but policies are missing
    # This handles the case where NiFi created the flow after initial provisioning
    if [ -f "$AUTH_XML" ] && [ -s "$FLOW_FILE" ]; then
        ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            # Check if root group policies already exist
            if ! grep -q "process-groups/$ROOT_ID" "$AUTH_XML"; then
                echo "Adding missing root group policies for ROOT_ID: $ROOT_ID"
                GROUP_ID=$(GET_UUID "group-NiFi Administrators")
                
                # Generate policy IDs
                P1=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
                P2=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
                P3=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
                P4=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
                P5=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
                P6=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
                
                # Create temporary file with new policies using echo
                echo "    <policy action=\"R\" identifier=\"$P1\" resource=\"/process-groups/$ROOT_ID\">" > /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P2\" resource=\"/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P3\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P4\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P5\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P6\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                
                # Insert before </policies> using sed with file read
                sed -i '/<\/policies>/e cat /tmp/new_policies.xml' "$AUTH_XML"
                rm -f /tmp/new_policies.xml
                echo "Root group policies added successfully."
            else
                echo "Root group policies already exist for ROOT_ID: $ROOT_ID"
            fi
        fi
    fi
    
    # Update authorizers.xml paths to point to persistent files (only for non-LDAP mode)
    conf_dir='/opt/nifi/nifi-current/persistent_conf'
    sed -i -E "s|(<property name=\"Authorizations File\">).*(</property>)|\1${conf_dir}/authorizations.xml\2|g" "${authorizers_file}"
    sed -i -E "s|(<property name=\"Users File\">).*(</property>)|\1${conf_dir}/users.xml\2|g" "${authorizers_file}"
    {{- end }}

    {{- /* Set file and directory paths to persistent locations */}}
    {{- with .Values.persistence }}
    conf_dir='./persistent_conf'
    prop_replace 'nifi.flow.configuration.file' "${conf_dir}/{{ .config.files.flowJson }}"
    prop_replace 'nifi.flow.configuration.archive.dir' "${conf_dir}/archive"
    {{- end }}

    {{- /* Define flowfile repository */}}
    {{- with .Values.persistence.repo.flowfile }}
    prop_replace 'nifi.flowfile.repository.directory' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define content repositories */}}
    prop_remove 'nifi.content.repository.directory.default'
    {{- range .Values.persistence.repo.content }}
    prop_add 'nifi.content.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define provenance repositories */}}
    prop_remove 'nifi.provenance.repository.directory.default'
    {{- range .Values.persistence.repo.provenance }}
    prop_add 'nifi.provenance.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define custom nar library path */}}
    prop_add 'nifi.nar.library.directory.custom' {{ .Values.customLibPath | squote }}

    {{- /* Generate a TLS cert for this node from the CSI-provided certificates and private key */}}
    {{- if .Values.global.tls.certificate }}
    cert_dir='/opt/certmanager'
    tls_dir='/opt/tls'
    rm -f $tls_dir/*
    openssl pkcs12 -export \
      -in $cert_dir/tls.crt \
      -inkey $cert_dir/tls.key \
      -CAfile $cert_dir/ca.crt \
      -passout "pass:${KEYSTORE_PASSWORD}" \
      -out $tls_dir/keystore.p12
    keytool -import -noprompt -trustcacerts \
      -file $cert_dir/ca.crt \
      -storepass "${TRUSTSTORE_PASSWORD}" \
      -destkeystore $tls_dir/truststore.p12 \
      -deststoretype pkcs12
    {{- end }}

    {{- /* Task termination period */}}
    prop_replace 'graceful.shutdown.seconds' {{ .Values.shutdown.gracefulShutdownSeconds }} "${bootstrap_file}"

    {{- /* Set UI autorefresh interval */}}
    prop_replace 'nifi.ui.autorefresh.interval' {{ .Values.ui.refreshInterval | squote }}

    {{- with .Values.ui.timeZone }}
    echo 'java.arg.8=-Duser.timezone={{ . }}' >> "${bootstrap_file}"
    {{- end }}

    {{- with .Values.ui.maxThreads }}
    prop_replace 'nifi.web.jetty.threads' {{ . | squote }}
    {{- end }}

    {{- /* Set user logging levels */}}
    {{- range $logger, $level := .Values.logging.levels }}
    xmlstarlet ed --inplace --update "//logger[@name='{{ $logger }}']/@level" --value '{{ $level }}' "${logback_file}"
    {{- end }}

    {{- /* Set user logging max size capping */}}
    {{- range $appender, $size := .Values.logging.totalSizeCap }}
    xmlstarlet ed -L -s '//appender[@name="{{ $appender }}"]/rollingPolicy' -t elem -n 'totalSizeCap' -v '{{ $size }}' "${logback_file}"
    {{- end }}

    {{- range $key, $value := .Values.extraConfig.nifiProperties }}
    prop_replace {{ $key | squote }} {{ $value | quote }}
    {{- end }}

    {{- if .Values.debugStartup }}
    sleep 1000000
    {{- end }}

    {{- with .Values.umask }}
    umask {{ . }}
    {{- end }}

    exec $scripts_dir/start.sh
  custom-startup.sh: |
    #!/bin/bash

    # NiFi toolkit CLI path
    NIFI_CLI="/opt/nifi/nifi-toolkit-current/bin/cli.sh"

    # NiFi Cluster variables (use a proper hostname substitution here)
    NIFI_URL="https://{{ $serviceHostName }}:8443"

    # Log file path (update to your desired destination)
    LOG_FILE="/opt/nifi/nifi-current/logs/k8s-pre-stop.log"

    # Redirect all output (stdout and stderr) to the log file
    exec > >(tee -a "$LOG_FILE") 2>&1

    # Function to get the status of the node
    get_node_status() {
      NODE_ID="$1"
      NODE_STATUS=$($NIFI_CLI nifi get-node --nifiNodeId "$NODE_ID" -u "$NIFI_URL" -ot json | jq -r '.node.status')
      echo "$NODE_STATUS"
    }

    # Retry function for critical steps (like disconnecting or offloading nodes)
    retry_command() {
      local retries=5
      local wait_time=5
      local cmd="$@"
      
      for ((i=1; i<=retries; i++)); do
        eval "$cmd"
        if [ $? -eq 0 ]; then
          return 0
        fi
        echo "$(date): Command failed. Retrying in $wait_time seconds... (Attempt $i/$retries)"
        sleep $wait_time
      done
      
      echo "$(date): Command failed after $retries attempts. Exiting."
      exit 1
    }

    # Get the hostname
    HOSTNAME=$(hostname)
    echo "$(date): Retrieving node information for the hostname: $HOSTNAME..."

    # Retrieve the list of nodes
    NODE_INFO=$($NIFI_CLI nifi get-nodes -u "$NIFI_URL")

    # Check if NODE_INFO is empty (failed retrieval)
    if [ -z "$NODE_INFO" ]; then
      echo "$(date): Failed to retrieve node information. Exiting."
      exit 1
    fi

    # Extract the node ID based on the hostname

    NODE_ID=$(echo "$NODE_INFO" | grep "$HOSTNAME" | awk '{print $2}')

    # Check if the NODE_ID is empty
    if [ -z "$NODE_ID" ]; then
      echo "$(date): WARNING: Node ID for $HOSTNAME not found. Skipping node operations."

      if [ -z "$NODE_ID" ]; then
        echo "$(date): WARNING: Node ID for $HOSTNAME not found. Skipping all node operations."
      else
        echo "$(date): Node ID for $HOSTNAME is $NODE_ID"

        # Get the current node status
        CURRENT_STATUS=$(get_node_status "$NODE_ID")
        echo "$(date): Current node status: $CURRENT_STATUS"

        # Disconnect the current node if it is not already disconnected
        if [ "$CURRENT_STATUS" != "DISCONNECTED" ]; then
          echo "$(date): Disconnecting node $NODE_ID..."
          retry_command "$NIFI_CLI nifi disconnect-node --nifiNodeId $NODE_ID"
          echo "$(date): Node $NODE_ID disconnected."
        else
          echo "$(date): Node $NODE_ID is already disconnected."
        fi

        # Offload the current node if not already offloaded
        if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
          echo "$(date): Offloading node $NODE_ID..."
          retry_command "$NIFI_CLI nifi offload-node --nifiNodeId $NODE_ID --connectionTimeout 60000 --readTimeout 60000 -u $NIFI_URL"
          echo "$(date): Node $NODE_ID offloading..."
        else
          echo "$(date): Node $NODE_ID is already offloaded."
        fi

        # Wait for the node to be fully offloaded with a retry limit
        MAX_ATTEMPTS=12  # Limit the retries to 12 (with 5-second interval = 1 minute total)
        attempt=1
        while [ $attempt -le $MAX_ATTEMPTS ]; do
          CURRENT_STATUS=$(get_node_status "$NODE_ID")
          if [ "$CURRENT_STATUS" == "OFFLOADED" ]; then
            echo "$(date): Node $NODE_ID successfully offloaded."
            break
          else
            echo "$(date): Current node status: $CURRENT_STATUS. Retrying in 5 seconds... (Attempt $attempt/$MAX_ATTEMPTS)"
            attempt=$((attempt+1))
            sleep 5
          fi
        done

        # If the node hasn't offloaded after the max attempts, exit with an error
        CURRENT_STATUS=$(get_node_status "$NODE_ID")
        if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
          echo "$(date): Node $NODE_ID failed to offload after $MAX_ATTEMPTS attempts. Exiting."
          exit 1
        fi

        # Remove the node
        echo "$(date): Removing node $NODE_ID..."
        retry_command "$NIFI_CLI nifi delete-node --nifiNodeId $NODE_ID -u $NIFI_URL"
        echo "$(date): Node $NODE_ID offloaded and removed successfully."
      fi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" $ }}-filebeat
  labels:
    {{- include "nifi.labels" $ | nindent 4 }}
data:
  filebeat.yml: |
    tags:
      {{- toYaml .tags | nindent 6 }}
    filebeat.inputs:
      - type: filestream
        id: nifi-app
        fields:
          log_id: app
        paths: ["/nifi/logs/nifi-app*.log"]
      - type: filestream
        id: nifi-request
        fields:
          log_id: request
        paths: ["/nifi/logs/nifi-request*.log"]
      - type: filestream
        id: nifi-user
        fields:
          log_id: user
        paths: ["/nifi/logs/nifi-user*.log"]
    {{- if or .labels .processors }}
    processors:
      {{- if .labels }}
      - add_labels:
          labels:
            {{- toYaml .labels | nindent 12 }}
      {{- end }}
      {{- toYaml .processors | nindent 6 }}
    {{- end }}
    {{ printf "output.%s:" .output.type }}
    {{- toYaml .output.parameters | nindent 6 }}
    queue.mem:
      flush.timeout: {{ .queue.flushTimeout }}
{{- end }}
{{- end }}
