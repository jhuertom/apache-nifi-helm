{{- $serviceHostName := printf "%s-http.%s" (include "nifi.fullname" . ) .Release.Namespace }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" . }}
  labels:
    {{- include "nifi.labels" . | nindent 4 }}
data:
  custom-startup.sh: |
    #!/bin/bash -e

    prop_add () {
      target_file="${3:-${nifi_props_file}}"
      echo "adding property to target file ${target_file}"
      echo "$1=$2" >> "${target_file}"
    }

    prop_remove () {
      target_file="${3:-${nifi_props_file}}"
      echo "removing property from target file ${target_file}"
      sed -i -e "s|^$1=.*$||" "${target_file}"
    }

    authorizers_file='conf/authorizers.xml'
    bootstrap_file='conf/bootstrap.conf'
    nifi_properties_file='conf/nifi.properties'
    logback_file='conf/logback.xml'
    scripts_dir='/opt/nifi/scripts'
    [ -f "${scripts_dir}/common.sh" ] && . "${scripts_dir}/common.sh"

    {{- /* Set host connection properties so the node is reachable, with TLS hostname verification */}}
    host_name="${HOSTNAME}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
    pod_index=$(echo ${HOSTNAME} | sed -E 's/^.*([0-9]+)$/\1/g')

    prop_replace 'nifi.web.https.host' "${host_name}"
    export NIFI_WEB_HTTPS_HOST="${host_name}"
    export NIFI_WEB_PROXY_HOST=" \
      ${host_name}, \
      {{ .Values.ingress.hostName }}, \
      {{ include "nifi.siteToSiteHostName" . }}, \
      {{ include "nifi.siteToSiteHostName" . }}:443, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}:443, \
      {{ $serviceHostName }}, \
      {{ $serviceHostName }}:{{ .Values.ports.https }}"

    {{- /* S2S cluster-local connections */}}
    export NIFI_REMOTE_INPUT_HOST="${HOSTNAME}"
    prop_add 'nifi.remote.route.raw.cluster.when' '${s2s.source.hostname:equals('\''{{ $serviceHostName }}'\'')}'
    prop_add 'nifi.remote.route.raw.cluster.hostname' '${s2s.target.hostname}'
    prop_add 'nifi.remote.route.raw.cluster.port' {{ .Values.ports.remoteinput | squote }}
    prop_add 'nifi.remote.route.raw.cluster.secure' 'true'

    {{- /* S2S connections via Ingress */}}
    prop_add 'nifi.remote.route.http.ingress.when' '${X-ProxyHost:contains('\''{{ include "nifi.siteToSiteHostName" . }}'\'')}'
    prop_add 'nifi.remote.route.http.ingress.hostname' '${s2s.target.hostname}.{{ include "nifi.siteToSiteHostName" . }}'
    prop_add 'nifi.remote.route.http.ingress.port' '443'
    prop_add 'nifi.remote.route.http.ingress.secure' 'true'

    {{- /* Configure authentication method based on priority: OIDC > LDAP > Basic */}}
    {{- if .Values.global.oidc.enabled }}
    echo "Enabling OIDC authentication"
    prop_replace 'nifi.security.user.oidc.discovery.url' '{{ .Values.global.oidc.oidc_url }}'
    prop_replace 'nifi.security.user.oidc.client.id' '{{ .Values.global.oidc.client_id }}'
    prop_replace 'nifi.security.user.oidc.claim.identifying.user' '{{ .Values.global.oidc.claim_identifying_user }}'
    {{- else if .Values.global.ldap.enabled }}
    echo "Enabling LDAP user authentication"
    # Disable Single User provider completely
    export SINGLE_USER_CREDENTIALS_USERNAME=""
    export SINGLE_USER_CREDENTIALS_PASSWORD=""
    
    # Remove single-user-provider from login-identity-providers.xml
    xmlstarlet ed --inplace -d "//provider[identifier='single-user-provider']" 'conf/login-identity-providers.xml'
    
    # Configure LDAP provider in login-identity-providers.xml
    echo "Configuring login-identity-providers.xml for LDAP..."
    
    # Check if ldap-provider exists, if not create it
    if ! xmlstarlet sel -t -v "//provider[identifier='ldap-provider']" 'conf/login-identity-providers.xml' > /dev/null 2>&1; then
      echo "Creating ldap-provider in login-identity-providers.xml..."
      # Add ldap-provider after removing single-user-provider
      xmlstarlet ed --inplace \
        --subnode "/loginIdentityProviders" \
        --type elem -n "provider" \
        'conf/login-identity-providers.xml'
      
      # Add identifier
      xmlstarlet ed --inplace \
        --subnode "//loginIdentityProviders/provider[last()]" \
        --type elem -n "identifier" -v "ldap-provider" \
        'conf/login-identity-providers.xml'
      
      # Add class
      xmlstarlet ed --inplace \
        --subnode "//loginIdentityProviders/provider[last()]" \
        --type elem -n "class" -v "org.apache.nifi.ldap.LdapProvider" \
        'conf/login-identity-providers.xml'
    fi
    
    # Configure LDAP provider properties
    # Helper function to add or update property
    update_or_add_ldap_property() {
      local prop_name="$1"
      local prop_value="$2"
      local file='conf/login-identity-providers.xml'
      
      if xmlstarlet sel -t -v "//provider[identifier='ldap-provider']/property[@name='$prop_name']" "$file" > /dev/null 2>&1; then
        xmlstarlet ed --inplace \
          --update "//provider[identifier='ldap-provider']/property[@name='$prop_name']" \
          --value "$prop_value" \
          "$file"
      else
        xmlstarlet ed --inplace \
          --subnode "//provider[identifier='ldap-provider']" \
          --type elem -n "property" -v "$prop_value" \
          "$file"
        xmlstarlet ed --inplace \
          --insert "//provider[identifier='ldap-provider']/property[last()]" \
          --type attr -n "name" -v "$prop_name" \
          "$file"
      fi
    }
    
    update_or_add_ldap_property "Authentication Strategy" "{{ .Values.global.ldap.authenticationStrategy }}"
    update_or_add_ldap_property "Manager DN" "{{ .Values.global.ldap.manager.distinguishedName }}"
    update_or_add_ldap_property "Manager Password" "${LDAP_MANAGER_PASSWORD}"
    update_or_add_ldap_property "Referral Strategy" "FOLLOW"
    update_or_add_ldap_property "Connect Timeout" "10 secs"
    update_or_add_ldap_property "Read Timeout" "10 secs"
    update_or_add_ldap_property "Url" "{{ .Values.global.ldap.url }}"
    update_or_add_ldap_property "User Search Base" "{{ .Values.global.ldap.userSearchBase }}"
    update_or_add_ldap_property "User Search Filter" "{{ .Values.global.ldap.userSearchFilter }}"
    update_or_add_ldap_property "Identity Strategy" "{{ .Values.global.ldap.identityStrategy }}"
    update_or_add_ldap_property "Authentication Expiration" "12 hours"
    
    {{- if or (eq .Values.global.ldap.authenticationStrategy "LDAPS") (eq .Values.global.ldap.authenticationStrategy "START_TLS") }}
    update_or_add_ldap_property "TLS - Protocol" "{{ .Values.global.ldap.tlsProtocol }}"
    update_or_add_ldap_property "TLS - Keystore" "${LDAP_TLS_KEYSTORE}"
    update_or_add_ldap_property "TLS - Keystore Password" "${LDAP_TLS_KEYSTORE_PASSWORD}"
    update_or_add_ldap_property "TLS - Keystore Type" "PKCS12"
    update_or_add_ldap_property "TLS - Truststore" "${LDAP_TLS_TRUSTSTORE}"
    update_or_add_ldap_property "TLS - Truststore Password" "${LDAP_TLS_TRUSTSTORE_PASSWORD}"
    update_or_add_ldap_property "TLS - Truststore Type" "PKCS12"
    {{- end }}
    
    echo "login-identity-providers.xml configured successfully."
    
    # Set the authorizer and login identity provider
    prop_replace 'nifi.security.user.authorizer' 'managed-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'ldap-provider'
    
    # IMPORTANT: Let NiFi manage authorization files automatically
    # When users.xml/authorizations.xml don't exist, NiFi creates them with Initial Admin Identity
    # We should NOT delete them on each restart - that breaks persistent permissions
    echo "LDAP configured. NiFi will auto-create authorization files if needed."
    
    {{- else }}
    echo "Enabling Single User (Basic) authentication"
    prop_replace 'nifi.security.user.authorizer' 'single-user-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'single-user-provider'
    {{- end }}

    {{- /* Replace properties not exposed by environment variables */}}
    {{- if eq (include "nifi.useZooKeeper" .) "true" }}
    prop_replace 'nifi.zookeeper.client.secure' 'false'
    {{- else }}
    prop_replace 'nifi.state.management.provider.cluster' 'kubernetes-provider'
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Name Prefix']" --value '{{ .Values.stateManagement.kubernetes.statePrefix }}' "conf/state-management.xml"
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Namespace']" --value '{{ include "nifi.stateManagementNamespace" . }}' "conf/state-management.xml"
    {{- end }}

    # Absolute paths for persistence
    PERSISTENT_CONF_DIR='/opt/nifi/nifi-current/persistent_conf'
    USERS_XML="${PERSISTENT_CONF_DIR}/users.xml"
    AUTH_XML="${PERSISTENT_CONF_DIR}/authorizations.xml"
    FLOW_FILE="${PERSISTENT_CONF_DIR}/flow.json.gz"

    # Deterministic UUID Generator (NiFi-aligned Version 3 UUID)
    GET_UUID() {
      python3 -c "import uuid, hashlib; md5 = hashlib.md5('$1'.encode('utf-8')).digest(); uid = list(md5); uid[6] = (uid[6] & 0x0f) | 0x30; uid[8] = (uid[8] & 0x3f) | 0x80; print(str(uuid.UUID(bytes=bytes(uid))))"
    }

    # INITIAL REGISTRY PROVISIONING
    # For LDAP, we need to create users.xml with the Initial Admin Identity
    # so FileAccessPolicyProvider can find it and create initial policies
    {{- if .Values.global.ldap.enabled }}
    if [ ! -f "$USERS_XML" ]; then
        echo "LDAP mode: Creating users.xml with Initial Admin Identity for policy seeding..."
        mkdir -p "$PERSISTENT_CONF_DIR"
        
        ADMIN_IDENTITY="{{ .Values.global.ldap.initialAdminIdentity }}"
        ADMIN_ID=$(GET_UUID "user-$ADMIN_IDENTITY")
        
        # Also add node identities for cluster communication
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$USERS_XML"
        echo '<tenants>' >> "$USERS_XML"
        echo '  <groups/>' >> "$USERS_XML"
        echo '  <users>' >> "$USERS_XML"
        echo "    <user identifier=\"$ADMIN_ID\" identity=\"$ADMIN_IDENTITY\"/>" >> "$USERS_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        NODE_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
        NODE_ID=$(GET_UUID "user-$NODE_DN")
        echo "    <user identifier=\"$NODE_ID\" identity=\"$NODE_DN\"/>" >> "$USERS_XML"
        {{- end }}
        echo '  </users>' >> "$USERS_XML"
        echo '</tenants>' >> "$USERS_XML"
        
        echo "Created users.xml with admin: $ADMIN_IDENTITY"
        cat "$USERS_XML"
    fi
    {{- else }}
    # Non-LDAP mode: Create users.xml and authorizations.xml manually
    if [ ! -f "$USERS_XML" ]; then
        echo "Provisioning initial security registry..."
        mkdir -p "$PERSISTENT_CONF_DIR"

        # BUILD IDENTITIES LIST
        ADMIN_IDENTITIES=""
        # NiFi Nodes
        for (( i = 0; i < {{ .Values.global.nifi.nodeCount }}; i++ )); do
            ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}-${i}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        done
        # Ingress Node
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        # LDAP Admin
        {{- if and .Values.global.ldap.enabled .Values.global.ldap.initialAdminIdentity }}
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} {{ .Values.global.ldap.initialAdminIdentity }}"
        {{- end }}

        echo "Identities to authorize:$ADMIN_IDENTITIES"

        # 1. Generate users.xml
        # We'll create a group called 'NiFi Administrators' and add everyone to it.
        # CRITICAL: In NiFi 2.x, <groups> MUST come BEFORE <users> in the <tenants> element.
        GROUP_NAME="NiFi Administrators"
        GROUP_ID=$(GET_UUID "group-$GROUP_NAME")

        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$USERS_XML"
        echo '<tenants>' >> "$USERS_XML"
        echo '  <groups>' >> "$USERS_XML"
        echo "    <group identifier=\"$GROUP_ID\" name=\"$GROUP_NAME\">" >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "      <user identifier=\"$U_ID\"/>" >> "$USERS_XML"
        done
        echo '    </group>' >> "$USERS_XML"
        echo '  </groups>' >> "$USERS_XML"
        echo '  <users>' >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "    <user identifier=\"$U_ID\" identity=\"$DN\"/>" >> "$USERS_XML"
        done
        echo '  </users>' >> "$USERS_XML"
        echo '</tenants>' >> "$USERS_XML"

        # 2. Generate authorizations.xml
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$AUTH_XML"
        echo '<authorizations>' >> "$AUTH_XML"
        echo '  <policies>' >> "$AUTH_XML"
        
        RESOURCES="/flow /controller /proxy /restricted-components /tenants /policies"
        
        # Access Root Group - Get ROOT_ID from existing flow or wait for it
        ROOT_ID=""
        if [ -s "$FLOW_FILE" ]; then
            ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        fi
        
        # If no flow exists yet, we'll add root group policies after NiFi creates the flow
        # For now, add a placeholder that will be updated on subsequent restarts
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            echo "Found existing ROOT_ID: $ROOT_ID"
            RESOURCES="$RESOURCES /process-groups/$ROOT_ID /data/process-groups/$ROOT_ID /operation/process-groups/$ROOT_ID"
        else
            echo "No flow.json.gz found yet. Root group policies will be added after first NiFi startup."
        fi

        for RES in $RESOURCES; do
            for ACT in R W; do
                P_ID=$(GET_UUID "policy-$RES-$ACT")
                echo "    <policy action=\"$ACT\" identifier=\"$P_ID\" resource=\"$RES\">" >> "$AUTH_XML"
                echo "      <group identifier=\"$GROUP_ID\"/>" >> "$AUTH_XML"
                echo "    </policy>" >> "$AUTH_XML"
            done
        done
        echo '  </policies>' >> "$AUTH_XML"
        echo '</authorizations>' >> "$AUTH_XML"
        echo "Security registry provisioned successfully."
    fi
    {{- end }}

    {{- if not .Values.global.ldap.enabled }}
    # UPDATE ROOT GROUP POLICIES if flow.json.gz exists but policies are missing
    # This handles the case where NiFi created the flow after initial provisioning
    if [ -f "$AUTH_XML" ] && [ -s "$FLOW_FILE" ]; then
        ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            # Check if root group policies already exist
            if ! grep -q "process-groups/$ROOT_ID" "$AUTH_XML"; then
                echo "Adding missing root group policies for ROOT_ID: $ROOT_ID"
                GROUP_ID=$(GET_UUID "group-NiFi Administrators")
                
                # Generate policy IDs
                P1=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
                P2=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
                P3=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
                P4=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
                P5=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
                P6=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
                
                # Create temporary file with new policies using echo
                echo "    <policy action=\"R\" identifier=\"$P1\" resource=\"/process-groups/$ROOT_ID\">" > /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P2\" resource=\"/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P3\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P4\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P5\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P6\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                
                # Insert before </policies> using sed with file read
                sed -i '/<\/policies>/e cat /tmp/new_policies.xml' "$AUTH_XML"
                rm -f /tmp/new_policies.xml
                echo "Root group policies added successfully."
            else
                echo "Root group policies already exist for ROOT_ID: $ROOT_ID"
            fi
        fi
    fi
    {{- end }}

    echo "DEBUG: users.xml content:"
    [ -f "$USERS_XML" ] && cat "$USERS_XML" || echo "users.xml NOT FOUND"
    echo "DEBUG: authorizations.xml content:"
    [ -f "$AUTH_XML" ] && cat "$AUTH_XML" || echo "authorizations.xml NOT FOUND"
    echo "DEBUG: Finished registry print."

    # Update authorizers.xml paths to point to persistent files
    conf_dir='/opt/nifi/nifi-current/persistent_conf'
    sed -i -E "s|(<property name=\"Authorizations File\">).*(</property>)|\1${conf_dir}/authorizations.xml\2|g" "${authorizers_file}"
    sed -i -E "s|(<property name=\"Users File\">).*(</property>)|\1${conf_dir}/users.xml\2|g" "${authorizers_file}"

    {{- /* Configure authorizers.xml for LDAP authentication */}}
    {{- if .Values.global.ldap.enabled }}
    echo "Configuring authorizers.xml for LDAP authentication..."
    
    # Enable (uncomment) the ldap-user-group-provider - remove both comment lines
    sed -i '/<!-- To enable the ldap-user-group-provider remove 2 lines. This is 1 of 2./d' "${authorizers_file}"
    sed -i '/To enable the ldap-user-group-provider remove 2 lines. This is 2 of 2. -->/d' "${authorizers_file}"
    
    echo "LDAP provider uncommented. Configuring properties..."
    
    # Configure the ldap-user-group-provider - CRITICAL: Must set Url first
    echo "Setting LDAP URL: {{ .Values.global.ldap.url }}"
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Url']" \
      --value '{{ .Values.global.ldap.url }}' \
      "${authorizers_file}" || echo "ERROR: Failed to set LDAP URL"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Authentication Strategy']" \
      --value '{{ .Values.global.ldap.authenticationStrategy }}' \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Manager DN']" \
      --value '{{ .Values.global.ldap.manager.distinguishedName }}' \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Manager Password']" \
      --value "${LDAP_MANAGER_PASSWORD}" \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Protocol']" \
      --value '{{ .Values.global.ldap.tlsProtocol }}' \
      "${authorizers_file}"
    
    {{- if or (eq .Values.global.ldap.authenticationStrategy "LDAPS") (eq .Values.global.ldap.authenticationStrategy "START_TLS") }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Keystore']" \
      --value "${LDAP_TLS_KEYSTORE}" \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Keystore Password']" \
      --value "${LDAP_TLS_KEYSTORE_PASSWORD}" \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Keystore Type']" \
      --value 'PKCS12' \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Truststore']" \
      --value "${LDAP_TLS_TRUSTSTORE}" \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Truststore Password']" \
      --value "${LDAP_TLS_TRUSTSTORE_PASSWORD}" \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='TLS - Truststore Type']" \
      --value 'PKCS12' \
      "${authorizers_file}"
    {{- end }}
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Url']" \
      --value '{{ .Values.global.ldap.url }}' \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='User Search Base']" \
      --value '{{ .Values.global.ldap.userSearchBase }}' \
      "${authorizers_file}"
    
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='User Search Filter']" \
      --value '{{ .Values.global.ldap.userSearchFilter }}' \
      "${authorizers_file}"
    
    {{- if eq .Values.global.ldap.identityStrategy "USE_DN" }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Identity Strategy']" \
      --value 'USE_DN' \
      "${authorizers_file}"
    {{- else }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Identity Strategy']" \
      --value 'USE_USERNAME' \
      "${authorizers_file}"
    {{- end }}
    
    {{- if .Values.global.ldap.groupSearchBase }}
    # Configure LDAP group synchronization
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Group Search Base']" \
      --value '{{ .Values.global.ldap.groupSearchBase }}' \
      "${authorizers_file}"
    
    {{- if .Values.global.ldap.groupSearchFilter }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Group Search Filter']" \
      --value '{{ .Values.global.ldap.groupSearchFilter }}' \
      "${authorizers_file}"
    {{- end }}
    
    {{- if .Values.global.ldap.groupMembershipAttribute }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Group Membership - Enforce Case Sensitivity']" \
      --value 'false' \
      "${authorizers_file}"
    {{- end }}
    
    {{- if .Values.global.ldap.groupNameAttribute }}
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='Group Name Attribute']" \
      --value '{{ .Values.global.ldap.groupNameAttribute }}' \
      "${authorizers_file}"
    {{- end }}
    {{- end }}
    
    # Configure User Identity Attribute to align with authentication (usually uid or sAMAccountName)
    # This prevents identity conflicts where authentication sees "user" but authorization sees "DN"
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='ldap-user-group-provider']/property[@name='User Identity Attribute']" \
      --value 'uid' \
      "${authorizers_file}"

    # Enable composite provider
    echo "Enabling composite-configurable-user-group-provider..."
    sed -i '/<!-- To enable the composite-configurable-user-group-provider remove 2 lines. This is 1 of 2./d' "${authorizers_file}"
    sed -i '/To enable the composite-configurable-user-group-provider remove 2 lines. This is 2 of 2. -->/d' "${authorizers_file}"
    
    # CRITICAL FIX: composite-configurable-user-group-provider already has file-user-group-provider
    # as its internal configurable provider. We only need to add ldap-user-group-provider
    # as the non-configurable provider in position 1.
    # DO NOT add file-user-group-provider here - it causes "Duplicate provider" error
    xmlstarlet ed --inplace \
      --update "//userGroupProvider[identifier='composite-configurable-user-group-provider']/property[@name='User Group Provider 1']" \
      --value 'ldap-user-group-provider' \
      "${authorizers_file}"
    
    # Use composite provider in managed-authorizer
    echo "Configuring managed-authorizer to use composite provider..."
    xmlstarlet ed --inplace \
      --update "//accessPolicyProvider[identifier='file-access-policy-provider']/property[@name='User Group Provider']" \
      --value 'composite-configurable-user-group-provider' \
      "${authorizers_file}"

    # Native Bootstrap Alignment - Set Initial Admin Identity in authorizers.xml
    {{- if and .Values.global.ldap.enabled .Values.global.ldap.initialAdminIdentity }}
    echo "Aligning native authorizers.xml with LDAP Admin: {{ .Values.global.ldap.initialAdminIdentity }}"
    xmlstarlet ed --inplace \
      --update "//accessPolicyProvider[identifier='file-access-policy-provider']/property[@name='Initial Admin Identity']" \
      --value '{{ .Values.global.ldap.initialAdminIdentity }}' \
      "${authorizers_file}"
    {{- end }}

    # Set Node Identities in authorizers.xml for native cluster sync
    for (( i = 0; i < {{ .Values.global.nifi.nodeCount }}; i++ )); do
        NODE_DN="CN={{ include "nifi.fullname" . }}-${i}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        INDEX=$((i + 1))
        echo "Registering Node Identity $INDEX: $NODE_DN"
        # Since the property Node Identity [unique key] is dynamic, we add it if it doesn't exist
        if ! grep -q "Node Identity $INDEX" "${authorizers_file}"; then
            xmlstarlet ed --inplace \
              --subnode "//accessPolicyProvider[identifier='file-access-policy-provider']" \
              --type elem -n "property" -v "$NODE_DN" \
              "${authorizers_file}"
            xmlstarlet ed --inplace \
              --insert "//accessPolicyProvider[identifier='file-access-policy-provider']/property[last()]" \
              --type attr -n "name" -v "Node Identity $INDEX" \
              "${authorizers_file}"
        else
             xmlstarlet ed --inplace \
              --update "//accessPolicyProvider[identifier='file-access-policy-provider']/property[@name='Node Identity $INDEX']" \
              --value "$NODE_DN" \
              "${authorizers_file}"
        fi
    done

    echo "LDAP configuration completed with deterministic provisioning."
    {{- end }}

    {{- /* Set file and directory paths to persistent locations */}}
    {{- with .Values.persistence }}
    conf_dir='./persistent_conf'
    prop_replace 'nifi.flow.configuration.file' "${conf_dir}/{{ .config.files.flowJson }}"
    prop_replace 'nifi.flow.configuration.archive.dir' "${conf_dir}/archive"

    sed -i -E "s|(<property name=\"Authorizations File\">).*(</property>)|\1${conf_dir}/{{ .config.files.authorizations }}\2|g" "${authorizers_file}"
    sed -i -E "s|(<property name=\"Users File\">).*(</property>)|\1${conf_dir}/{{ .config.files.users }}\2|g" "${authorizers_file}"
    {{- end }}

    {{- /* Define flowfile repository */}}
    {{- with .Values.persistence.repo.flowfile }}
    prop_replace 'nifi.flowfile.repository.directory' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define content repositories */}}
    prop_remove 'nifi.content.repository.directory.default'
    {{- range .Values.persistence.repo.content }}
    prop_add 'nifi.content.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define provenance repositories */}}
    prop_remove 'nifi.provenance.repository.directory.default'
    {{- range .Values.persistence.repo.provenance }}
    prop_add 'nifi.provenance.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define custom nar library path */}}
    prop_add 'nifi.nar.library.directory.custom' {{ .Values.customLibPath | squote }}

    {{- /* Generate a TLS cert for this node from the CSI-provided certificates and private key */}}
    {{- if .Values.global.tls.certificate }}
    cert_dir='/opt/certmanager'
    tls_dir='/opt/tls'
    rm -f $tls_dir/*
    openssl pkcs12 -export \
      -in $cert_dir/tls.crt \
      -inkey $cert_dir/tls.key \
      -CAfile $cert_dir/ca.crt \
      -passout "pass:${KEYSTORE_PASSWORD}" \
      -out $tls_dir/keystore.p12
    keytool -import -noprompt -trustcacerts \
      -file $cert_dir/ca.crt \
      -storepass "${TRUSTSTORE_PASSWORD}" \
      -destkeystore $tls_dir/truststore.p12 \
      -deststoretype pkcs12
    {{- end }}

    {{- /* Task termination period */}}
    prop_replace 'graceful.shutdown.seconds' {{ .Values.shutdown.gracefulShutdownSeconds }} "${bootstrap_file}"

    {{- /* Set UI autorefresh interval */}}
    prop_replace 'nifi.ui.autorefresh.interval' {{ .Values.ui.refreshInterval | squote }}

    {{- with .Values.ui.timeZone }}
    echo 'java.arg.8=-Duser.timezone={{ . }}' >> "${bootstrap_file}"
    {{- end }}

    {{- with .Values.ui.maxThreads }}
    prop_replace 'nifi.web.jetty.threads' {{ . | squote }}
    {{- end }}

    {{- /* Set user logging levels */}}
    {{- range $logger, $level := .Values.logging.levels }}
    xmlstarlet ed --inplace --update "//logger[@name='{{ $logger }}']/@level" --value '{{ $level }}' "${logback_file}"
    {{- end }}

    {{- /* Set user logging max size capping */}}
    {{- range $appender, $size := .Values.logging.totalSizeCap }}
    xmlstarlet ed -L -s '//appender[@name="{{ $appender }}"]/rollingPolicy' -t elem -n 'totalSizeCap' -v '{{ $size }}' "${logback_file}"
    {{- end }}

    {{- range $key, $value := .Values.extraConfig.nifiProperties }}
    prop_replace {{ $key | squote }} {{ $value | quote }}
    {{- end }}

    {{- if .Values.debugStartup }}
    sleep 1000000
    {{- end }}

    {{- with .Values.umask }}
    umask {{ . }}
    {{- end }}

    exec $scripts_dir/start.sh
  pre-stop.sh: |
    #!/bin/bash

    # NiFi toolkit CLI path
    NIFI_CLI="/opt/nifi/nifi-toolkit-current/bin/cli.sh"

    # NiFi Cluster variables (use a proper hostname substitution here)
    NIFI_URL="https://{{ $serviceHostName }}:8443"

    # Log file path (update to your desired destination)
    LOG_FILE="/opt/nifi/nifi-current/logs/k8s-pre-stop.log"

    # Redirect all output (stdout and stderr) to the log file
    exec > >(tee -a "$LOG_FILE") 2>&1

    # Function to get the status of the node
    get_node_status() {
      NODE_ID="$1"
      NODE_STATUS=$($NIFI_CLI nifi get-node --nifiNodeId "$NODE_ID" -u "$NIFI_URL" -ot json | jq -r '.node.status')
      echo "$NODE_STATUS"
    }

    # Retry function for critical steps (like disconnecting or offloading nodes)
    retry_command() {
      local retries=5
      local wait_time=5
      local cmd="$@"
      
      for ((i=1; i<=retries; i++)); do
        eval "$cmd"
        if [ $? -eq 0 ]; then
          return 0
        fi
        echo "$(date): Command failed. Retrying in $wait_time seconds... (Attempt $i/$retries)"
        sleep $wait_time
      done
      
      echo "$(date): Command failed after $retries attempts. Exiting."
      exit 1
    }

    # Get the hostname
    HOSTNAME=$(hostname)
    echo "$(date): Retrieving node information for the hostname: $HOSTNAME..."

    # Retrieve the list of nodes
    NODE_INFO=$($NIFI_CLI nifi get-nodes -u "$NIFI_URL")

    # Check if NODE_INFO is empty (failed retrieval)
    if [ -z "$NODE_INFO" ]; then
      echo "$(date): Failed to retrieve node information. Exiting."
      exit 1
    fi

    # Extract the node ID based on the hostname
    NODE_ID=$(echo "$NODE_INFO" | grep "$HOSTNAME" | awk '{print $2}')

    # Check if the NODE_ID is empty
    if [ -z "$NODE_ID" ]; then
      echo "$(date): Node ID for $HOSTNAME not found. Exiting."
      exit 1
    fi

    echo "$(date): Node ID for $HOSTNAME is $NODE_ID"

    # Get the current node status
    CURRENT_STATUS=$(get_node_status "$NODE_ID")
    echo "$(date): Current node status: $CURRENT_STATUS"

    # Disconnect the current node if it is not already disconnected
    if [ "$CURRENT_STATUS" != "DISCONNECTED" ]; then
      echo "$(date): Disconnecting node $NODE_ID..."
      retry_command "$NIFI_CLI nifi disconnect-node --nifiNodeId $NODE_ID"
      echo "$(date): Node $NODE_ID disconnected."
    else
      echo "$(date): Node $NODE_ID is already disconnected."
    fi

    # Offload the current node if not already offloaded
    if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
      echo "$(date): Offloading node $NODE_ID..."
      retry_command "$NIFI_CLI nifi offload-node --nifiNodeId $NODE_ID --connectionTimeout 60000 --readTimeout 60000 -u $NIFI_URL"
      echo "$(date): Node $NODE_ID offloading..."
    else
      echo "$(date): Node $NODE_ID is already offloaded."
    fi

    # Wait for the node to be fully offloaded with a retry limit
    MAX_ATTEMPTS=12  # Limit the retries to 12 (with 5-second interval = 1 minute total)
    attempt=1
    while [ $attempt -le $MAX_ATTEMPTS ]; do
      CURRENT_STATUS=$(get_node_status "$NODE_ID")
      if [ "$CURRENT_STATUS" == "OFFLOADED" ]; then
        echo "$(date): Node $NODE_ID successfully offloaded."
        break
      else
        echo "$(date): Current node status: $CURRENT_STATUS. Retrying in 5 seconds... (Attempt $attempt/$MAX_ATTEMPTS)"
        attempt=$((attempt+1))
        sleep 5
      fi
    done

    # If the node hasn't offloaded after the max attempts, exit with an error
    CURRENT_STATUS=$(get_node_status "$NODE_ID")
    if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
      echo "$(date): Node $NODE_ID failed to offload after $MAX_ATTEMPTS attempts. Exiting."
      exit 1
    fi

    # Remove the node
    echo "$(date): Removing node $NODE_ID..."
    retry_command "$NIFI_CLI nifi delete-node --nifiNodeId $NODE_ID -u $NIFI_URL"
    echo "$(date): Node $NODE_ID offloaded and removed successfully."


{{- with .Values.filebeat }}
{{- if .enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" $ }}-filebeat
  labels:
    {{- include "nifi.labels" $ | nindent 4 }}
data:
  filebeat.yml: |
    tags:
      {{- toYaml .tags | nindent 6 }}
    filebeat.inputs:
      - type: filestream
        id: nifi-app
        fields:
          log_id: app
        paths: ["/nifi/logs/nifi-app*.log"]
      - type: filestream
        id: nifi-request
        fields:
          log_id: request
        paths: ["/nifi/logs/nifi-request*.log"]
      - type: filestream
        id: nifi-user
        fields:
          log_id: user
        paths: ["/nifi/logs/nifi-user*.log"]
    {{- if or .labels .processors }}
    processors:
      {{- if .labels }}
      - add_labels:
          labels:
            {{- toYaml .labels | nindent 12 }}
      {{- end }}
      {{- toYaml .processors | nindent 6 }}
    {{- end }}
    {{ printf "output.%s:" .output.type }}
    {{- toYaml .output.parameters | nindent 6 }}
    queue.mem:
      flush.timeout: {{ .queue.flushTimeout }}
{{- end }}
{{- end }}
