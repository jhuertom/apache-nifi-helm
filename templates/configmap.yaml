{{- $serviceHostName := printf "%s-http.%s" (include "nifi.fullname" . ) .Release.Namespace }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" . }}
  labels:
    {{- include "nifi.labels" . | nindent 4 }}
data:
  custom-startup.sh: |
    #!/bin/bash -e

    prop_add () {
      target_file="${3:-${nifi_props_file}}"
      echo "adding property to target file ${target_file}"
      echo "$1=$2" >> "${target_file}"
    }

    prop_remove () {
      target_file="${3:-${nifi_props_file}}"
      echo "removing property from target file ${target_file}"
      sed -i -e "s|^$1=.*$||" "${target_file}"
    }

    authorizers_file='conf/authorizers.xml'
    bootstrap_file='conf/bootstrap.conf'
    nifi_properties_file='conf/nifi.properties'
    logback_file='conf/logback.xml'
    scripts_dir='/opt/nifi/scripts'
    [ -f "${scripts_dir}/common.sh" ] && . "${scripts_dir}/common.sh"

    {{- /* Set host connection properties so the node is reachable, with TLS hostname verification */}}
    host_name="${HOSTNAME}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
    pod_index=$(echo ${HOSTNAME} | sed -E 's/^.*([0-9]+)$/\1/g')

    prop_replace 'nifi.web.https.host' "${host_name}"
    export NIFI_WEB_HTTPS_HOST="${host_name}"
    export NIFI_WEB_PROXY_HOST=" \
      ${host_name}, \
      {{ .Values.ingress.hostName }}, \
      {{ include "nifi.siteToSiteHostName" . }}, \
      {{ include "nifi.siteToSiteHostName" . }}:443, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}, \
      {{ printf "%s-${pod_index}.%s" (include "nifi.fullname" .) (include "nifi.siteToSiteHostName" .) }}:443, \
      {{ $serviceHostName }}, \
      {{ $serviceHostName }}:{{ .Values.ports.https }}"

    {{- /* S2S cluster-local connections */}}
    export NIFI_REMOTE_INPUT_HOST="${HOSTNAME}"
    prop_add 'nifi.remote.route.raw.cluster.when' '${s2s.source.hostname:equals('\''{{ $serviceHostName }}'\'')}'
    prop_add 'nifi.remote.route.raw.cluster.hostname' '${s2s.target.hostname}'
    prop_add 'nifi.remote.route.raw.cluster.port' {{ .Values.ports.remoteinput | squote }}
    prop_add 'nifi.remote.route.raw.cluster.secure' 'true'

    {{- /* S2S connections via Ingress */}}
    prop_add 'nifi.remote.route.http.ingress.when' '${X-ProxyHost:contains('\''{{ include "nifi.siteToSiteHostName" . }}'\'')}'
    prop_add 'nifi.remote.route.http.ingress.hostname' '${s2s.target.hostname}.{{ include "nifi.siteToSiteHostName" . }}'
    prop_add 'nifi.remote.route.http.ingress.port' '443'
    prop_add 'nifi.remote.route.http.ingress.secure' 'true'

    {{- /* Configure authentication method based on priority: OIDC > LDAP > Basic */}}
    {{- if .Values.global.oidc.enabled }}
    echo "Enabling OIDC authentication"
    prop_replace 'nifi.security.user.oidc.discovery.url' '{{ .Values.global.oidc.oidc_url }}'
    prop_replace 'nifi.security.user.oidc.client.id' '{{ .Values.global.oidc.client_id }}'
    prop_replace 'nifi.security.user.oidc.claim.identifying.user' '{{ .Values.global.oidc.claim_identifying_user }}'
    {{- else if .Values.global.ldap.enabled }}
    echo "Enabling LDAP user authentication"
    # Disable Single User provider completely
    export SINGLE_USER_CREDENTIALS_USERNAME=""
    export SINGLE_USER_CREDENTIALS_PASSWORD=""
    
    # CRITICAL: Create a clean login-identity-providers.xml with only ldap-provider
    # The original file has commented sections that cause duplicate provider issues
    echo "Creating clean login-identity-providers.xml for LDAP..."
    
    # Build the XML file using printf to avoid YAML parsing issues
    LOGIN_PROVIDERS_FILE='conf/login-identity-providers.xml'
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' > "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '<loginIdentityProviders>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '    <provider>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <identifier>ldap-provider</identifier>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <class>org.apache.nifi.ldap.LdapProvider</class>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Authentication Strategy">{{ .Values.global.ldap.authenticationStrategy }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Manager DN">{{ .Values.global.ldap.manager.distinguishedName }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' "        <property name=\"Manager Password\">${LDAP_MANAGER_PASSWORD}</property>" >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Password"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Keystore Type"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Password"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Truststore Type"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Client Auth"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Protocol">{{ .Values.global.ldap.tlsProtocol }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="TLS - Shutdown Gracefully"></property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Referral Strategy">FOLLOW</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Connect Timeout">10 secs</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Read Timeout">10 secs</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Url">{{ .Values.global.ldap.url }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="User Search Base">{{ .Values.global.ldap.userSearchBase }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="User Search Filter">{{ .Values.global.ldap.userSearchFilter }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Identity Strategy">{{ .Values.global.ldap.identityStrategy }}</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '        <property name="Authentication Expiration">12 hours</property>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '    </provider>' >> "$LOGIN_PROVIDERS_FILE"
    printf '%s\n' '</loginIdentityProviders>' >> "$LOGIN_PROVIDERS_FILE"
    
    {{- if or (eq .Values.global.ldap.authenticationStrategy "LDAPS") (eq .Values.global.ldap.authenticationStrategy "START_TLS") }}
    # Configure TLS settings for secure LDAP
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore']" \
      --value "${LDAP_TLS_KEYSTORE}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore Password']" \
      --value "${LDAP_TLS_KEYSTORE_PASSWORD}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Keystore Type']" \
      --value "PKCS12" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore']" \
      --value "${LDAP_TLS_TRUSTSTORE}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore Password']" \
      --value "${LDAP_TLS_TRUSTSTORE_PASSWORD}" \
      'conf/login-identity-providers.xml'
    xmlstarlet ed --inplace \
      --update "//provider[identifier='ldap-provider']/property[@name='TLS - Truststore Type']" \
      --value "PKCS12" \
      'conf/login-identity-providers.xml'
    {{- end }}
    
    echo "login-identity-providers.xml configured successfully."
    
    # Set the authorizer and login identity provider
    prop_replace 'nifi.security.user.authorizer' 'managed-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'ldap-provider'
    
    # CRITICAL: Create a clean authorizers.xml with ONLY LDAP (no single-user-authorizer)
    # This prevents NiFi from loading the single-user-authorizer at all
    echo "Creating clean authorizers.xml for LDAP-only authentication..."
    
    AUTHORIZERS_FILE='conf/authorizers.xml'
    cat > "$AUTHORIZERS_FILE" << 'AUTHEOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<authorizers>
    <userGroupProvider>
        <identifier>file-user-group-provider</identifier>
        <class>org.apache.nifi.authorization.FileUserGroupProvider</class>
        <property name="Users File">./persistent_conf/users.xml</property>
        <property name="Initial User Identity 1"></property>
    </userGroupProvider>

    <userGroupProvider>
        <identifier>ldap-user-group-provider</identifier>
        <class>org.apache.nifi.ldap.tenants.LdapUserGroupProvider</class>
        <property name="Authentication Strategy">__LDAP_AUTH_STRATEGY__</property>
        <property name="Manager DN">__LDAP_MANAGER_DN__</property>
        <property name="Manager Password">__LDAP_MANAGER_PASSWORD__</property>
        <property name="TLS - Keystore"></property>
        <property name="TLS - Keystore Password"></property>
        <property name="TLS - Keystore Type"></property>
        <property name="TLS - Truststore"></property>
        <property name="TLS - Truststore Password"></property>
        <property name="TLS - Truststore Type"></property>
        <property name="TLS - Client Auth"></property>
        <property name="TLS - Protocol">TLSv1.2</property>
        <property name="TLS - Shutdown Gracefully"></property>
        <property name="Referral Strategy">FOLLOW</property>
        <property name="Connect Timeout">10 secs</property>
        <property name="Read Timeout">10 secs</property>
        <property name="Url">__LDAP_URL__</property>
        <property name="Page Size"></property>
        <property name="Sync Interval">30 mins</property>
        <property name="Group Membership - Enforce Case Sensitivity">false</property>
        <property name="User Search Base">__LDAP_USER_SEARCH_BASE__</property>
        <property name="User Object Class">person</property>
        <property name="User Search Scope">ONE_LEVEL</property>
        <property name="User Search Filter">__LDAP_USER_SEARCH_FILTER__</property>
        <property name="User Identity Attribute">uid</property>
        <property name="User Group Name Attribute"></property>
        <property name="User Group Name Attribute - Referenced Group Attribute"></property>
        <property name="Group Search Base"></property>
        <property name="Group Object Class">group</property>
        <property name="Group Search Scope">ONE_LEVEL</property>
        <property name="Group Search Filter"></property>
        <property name="Group Name Attribute"></property>
        <property name="Group Member Attribute"></property>
        <property name="Group Member Attribute - Referenced User Attribute"></property>
    </userGroupProvider>

    <userGroupProvider>
        <identifier>composite-configurable-user-group-provider</identifier>
        <class>org.apache.nifi.authorization.CompositeConfigurableUserGroupProvider</class>
        <property name="Configurable User Group Provider">file-user-group-provider</property>
        <property name="User Group Provider 1">ldap-user-group-provider</property>
    </userGroupProvider>

    <accessPolicyProvider>
        <identifier>file-access-policy-provider</identifier>
        <class>org.apache.nifi.authorization.FileAccessPolicyProvider</class>
        <property name="User Group Provider">composite-configurable-user-group-provider</property>
        <property name="Authorizations File">./persistent_conf/authorizations.xml</property>
        <property name="Initial Admin Identity">__INITIAL_ADMIN_IDENTITY__</property>
        <property name="Node Identity 1">__NODE_IDENTITY_1__</property>
        <property name="Node Identity 2">__NODE_IDENTITY_2__</property>
        <property name="Node Identity 3">__NODE_IDENTITY_3__</property>
    </accessPolicyProvider>

    <authorizer>
        <identifier>managed-authorizer</identifier>
        <class>org.apache.nifi.authorization.StandardManagedAuthorizer</class>
        <property name="Access Policy Provider">file-access-policy-provider</property>
    </authorizer>
</authorizers>
AUTHEOF

    # Replace placeholders with actual values
    sed -i "s|__LDAP_AUTH_STRATEGY__|{{ .Values.global.ldap.authenticationStrategy }}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__LDAP_MANAGER_DN__|{{ .Values.global.ldap.manager.distinguishedName }}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__LDAP_MANAGER_PASSWORD__|${LDAP_MANAGER_PASSWORD}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__LDAP_URL__|{{ .Values.global.ldap.url }}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__LDAP_USER_SEARCH_BASE__|{{ .Values.global.ldap.userSearchBase }}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__LDAP_USER_SEARCH_FILTER__|{{ .Values.global.ldap.userSearchFilter }}|g" "$AUTHORIZERS_FILE"
    sed -i "s|__INITIAL_ADMIN_IDENTITY__|{{ .Values.global.ldap.initialAdminIdentity }}|g" "$AUTHORIZERS_FILE"
    
    # Set Node Identities
    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
    NODE{{ $i }}_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
    sed -i "s|__NODE_IDENTITY_{{ add $i 1 }}__|${NODE{{ $i }}_DN}|g" "$AUTHORIZERS_FILE"
    {{- end }}
    
    # Remove unused Node Identity placeholders (if nodeCount < 3)
    sed -i '/__NODE_IDENTITY_/d' "$AUTHORIZERS_FILE"
    
    echo "authorizers.xml created with LDAP-only configuration (no single-user-authorizer)."
    echo "LDAP authentication configured."
    
    {{- else }}
    echo "Enabling Single User (Basic) authentication"
    prop_replace 'nifi.security.user.authorizer' 'single-user-authorizer'
    prop_replace 'nifi.security.user.login.identity.provider' 'single-user-provider'
    {{- end }}

    {{- /* Replace properties not exposed by environment variables */}}
    {{- if eq (include "nifi.useZooKeeper" .) "true" }}
    prop_replace 'nifi.zookeeper.client.secure' 'false'
    {{- else }}
    prop_replace 'nifi.state.management.provider.cluster' 'kubernetes-provider'
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Name Prefix']" --value '{{ .Values.stateManagement.kubernetes.statePrefix }}' "conf/state-management.xml"
    xmlstarlet ed --inplace --update "/stateManagement/cluster-provider[id='kubernetes-provider']/property[@name='ConfigMap Namespace']" --value '{{ include "nifi.stateManagementNamespace" . }}' "conf/state-management.xml"
    {{- end }}

    # Absolute paths for persistence
    PERSISTENT_CONF_DIR='/opt/nifi/nifi-current/persistent_conf'
    USERS_XML="${PERSISTENT_CONF_DIR}/users.xml"
    AUTH_XML="${PERSISTENT_CONF_DIR}/authorizations.xml"
    FLOW_FILE="${PERSISTENT_CONF_DIR}/flow.json.gz"

    # Deterministic UUID Generator (NiFi-aligned Version 3 UUID)
    GET_UUID() {
      python3 -c "import uuid, hashlib; md5 = hashlib.md5('$1'.encode('utf-8')).digest(); uid = list(md5); uid[6] = (uid[6] & 0x0f) | 0x30; uid[8] = (uid[8] & 0x3f) | 0x80; print(str(uuid.UUID(bytes=bytes(uid))))"
    }

    # INITIAL REGISTRY PROVISIONING
    # For LDAP, we create complete users.xml and authorizations.xml
    # with all necessary users (admin, nodes, ingress) and policies
    {{- if .Values.global.ldap.enabled }}
    
    # First, create users.xml if it doesn't exist (always needed)
    if [ ! -f "$USERS_XML" ]; then
        echo "LDAP mode: Creating users.xml with all identities..."
        mkdir -p "$PERSISTENT_CONF_DIR"
        
        # Define all identities with deterministic UUIDs
        ADMIN_IDENTITY="{{ .Values.global.ldap.initialAdminIdentity }}"
        ADMIN_ID=$(GET_UUID "user-$ADMIN_IDENTITY")
        
        # Ingress identity (used by the Kubernetes ingress controller)
        INGRESS_DN="CN={{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        INGRESS_ID=$(GET_UUID "user-$INGRESS_DN")
        
        # Node identities
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        NODE{{ $i }}_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
        NODE{{ $i }}_ID=$(GET_UUID "user-$NODE{{ $i }}_DN")
        {{- end }}
        
        # ========== CREATE USERS.XML ==========
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$USERS_XML"
        echo '<tenants>' >> "$USERS_XML"
        echo '  <groups/>' >> "$USERS_XML"
        echo '  <users>' >> "$USERS_XML"
        echo "    <user identifier=\"$ADMIN_ID\" identity=\"$ADMIN_IDENTITY\"/>" >> "$USERS_XML"
        echo "    <user identifier=\"$INGRESS_ID\" identity=\"$INGRESS_DN\"/>" >> "$USERS_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        echo "    <user identifier=\"$NODE{{ $i }}_ID\" identity=\"$NODE{{ $i }}_DN\"/>" >> "$USERS_XML"
        {{- end }}
        echo '  </users>' >> "$USERS_XML"
        echo '</tenants>' >> "$USERS_XML"
        
        echo "Created users.xml with admin, ingress and node identities"
    fi
    
    # ========== CREATE AUTHORIZATIONS.XML ==========
    # This must include policies for the root process group
    if [ ! -f "$AUTH_XML" ]; then
        echo "LDAP mode: Creating authorizations.xml..."
        mkdir -p "$PERSISTENT_CONF_DIR"
        
        # Re-define identities (in case users.xml already existed)
        ADMIN_IDENTITY="{{ .Values.global.ldap.initialAdminIdentity }}"
        ADMIN_ID=$(GET_UUID "user-$ADMIN_IDENTITY")
        INGRESS_DN="CN={{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        INGRESS_ID=$(GET_UUID "user-$INGRESS_DN")
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        NODE{{ $i }}_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
        NODE{{ $i }}_ID=$(GET_UUID "user-$NODE{{ $i }}_DN")
        {{- end }}
        
        # Get ROOT_ID if flow exists, otherwise leave empty (will be added later by PolicyMonitor)
        ROOT_ID=""
        if [ -s "$FLOW_FILE" ]; then
            ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
            [ "$ROOT_ID" = "null" ] && ROOT_ID=""
        fi
        
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$AUTH_XML"
        echo '<authorizations>' >> "$AUTH_XML"
        echo '  <policies>' >> "$AUTH_XML"
        
        # /flow - Admin only (read)
        P_ID=$(GET_UUID "policy-/flow-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/flow\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /controller - Admin, Ingress and all nodes (read/write)
        P_ID=$(GET_UUID "policy-/controller-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/controller\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
        {{- end }}
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/controller-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/controller\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
        {{- end }}
        echo "    </policy>" >> "$AUTH_XML"
        
        # /proxy - Ingress and all nodes (required for cluster communication)
        P_ID=$(GET_UUID "policy-/proxy-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/proxy\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
        {{- end }}
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/proxy-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/proxy\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
        {{- end }}
        echo "    </policy>" >> "$AUTH_XML"
        
        # /tenants - Admin only
        P_ID=$(GET_UUID "policy-/tenants-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/tenants\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/tenants-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/tenants\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /policies - Admin only
        P_ID=$(GET_UUID "policy-/policies-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/policies\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/policies-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/policies\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /restricted-components - Admin only
        P_ID=$(GET_UUID "policy-/restricted-components-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/restricted-components\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/restricted-components-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/restricted-components\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /counters - Admin only
        P_ID=$(GET_UUID "policy-/counters-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/counters\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/counters-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/counters\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /system - Admin only
        P_ID=$(GET_UUID "policy-/system-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/system\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /provenance - Admin only
        P_ID=$(GET_UUID "policy-/provenance-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/provenance\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        P_ID=$(GET_UUID "policy-/provenance-W")
        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/provenance\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # /site-to-site - Admin only
        P_ID=$(GET_UUID "policy-/site-to-site-R")
        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/site-to-site\">" >> "$AUTH_XML"
        echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
        echo "    </policy>" >> "$AUTH_XML"
        
        # Root Process Group policies (if flow exists)
        # CRITICAL: Ingress and all nodes need access to /process-groups/{ROOT_ID}
        # because when users access via ingress, the request is proxied through cluster nodes
        if [ -n "$ROOT_ID" ]; then
            echo "Adding root process group policies for ROOT_ID: $ROOT_ID"
            
            # /process-groups/{ROOT_ID} - Admin, Ingress, and all nodes (for proxied requests)
            P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
            echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
            
            P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
            echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            echo "      <user identifier=\"$INGRESS_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
            
            P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
            echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
            
            P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
            echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
            
            P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
            echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
            
            P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
            echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">" >> "$AUTH_XML"
            echo "      <user identifier=\"$ADMIN_ID\"/>" >> "$AUTH_XML"
            {{- range $i := until (int .Values.global.nifi.nodeCount) }}
            echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>" >> "$AUTH_XML"
            {{- end }}
            echo "    </policy>" >> "$AUTH_XML"
        else
            echo "No flow.json.gz found yet. Root group policies will be added by NiFi automatically."
        fi
        
        echo '  </policies>' >> "$AUTH_XML"
        echo '</authorizations>' >> "$AUTH_XML"
        
        echo "Created authorizations.xml with all required policies"
    fi
    
    # UPDATE ROOT GROUP POLICIES if flow.json.gz exists but policies are missing
    # This handles the case where NiFi created the flow after initial provisioning
    if [ -f "$AUTH_XML" ] && [ -s "$FLOW_FILE" ]; then
        ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ]; then
            # Check if root group policies already exist
            if ! grep -q "process-groups/$ROOT_ID" "$AUTH_XML"; then
                echo "Adding missing root group policies for ROOT_ID: $ROOT_ID"
                ADMIN_ID=$(GET_UUID "user-{{ .Values.global.ldap.initialAdminIdentity }}")
                INGRESS_DN="CN={{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
                INGRESS_ID=$(GET_UUID "user-$INGRESS_DN")
                {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                NODE{{ $i }}_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
                NODE{{ $i }}_ID=$(GET_UUID "user-$NODE{{ $i }}_DN")
                {{- end }}
                
                # Create temporary file with new policies
                {
                    # /process-groups/{ROOT_ID} - Admin, Ingress, and all nodes
                    P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
                    echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    echo "      <user identifier=\"$INGRESS_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                    
                    P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
                    echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    echo "      <user identifier=\"$INGRESS_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                    
                    P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
                    echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                    
                    P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
                    echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                    
                    P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
                    echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                    
                    P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
                    echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">"
                    echo "      <user identifier=\"$ADMIN_ID\"/>"
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                    {{- end }}
                    echo "    </policy>"
                } > /tmp/new_policies.xml
                
                # Insert before </policies>
                sed -i '/<\/policies>/e cat /tmp/new_policies.xml' "$AUTH_XML"
                rm -f /tmp/new_policies.xml
                echo "Root group policies added successfully."
            fi
        fi
    fi
    
    # ========== BACKGROUND POLICY MONITOR ==========
    # This runs in the background and waits for NiFi to be ready, then checks
    # for any process groups without policies and adds them automatically.
    # This handles the case where NiFi creates a new ROOT_ID on first start.
    (
        echo "[PolicyMonitor] Starting background policy monitor..."
        
        # Wait for NiFi to be ready (up to 5 minutes)
        MAX_WAIT=300
        WAIT_INTERVAL=10
        ELAPSED=0
        
        while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check if NiFi is responding
            if curl -sk "https://localhost:8443/nifi-api/system-diagnostics" >/dev/null 2>&1; then
                echo "[PolicyMonitor] NiFi is ready after ${ELAPSED}s"
                break
            fi
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            echo "[PolicyMonitor] Waiting for NiFi... ${ELAPSED}s"
        done
        
        if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "[PolicyMonitor] Timeout waiting for NiFi. Exiting."
            exit 1
        fi
        
        # Wait a bit more for flow to stabilize
        sleep 30
        
        # Re-check flow.json.gz for ROOT_ID
        if [ -s "$FLOW_FILE" ]; then
            ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
            
            if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ]; then
                if ! grep -q "process-groups/$ROOT_ID" "$AUTH_XML" 2>/dev/null; then
                    echo "[PolicyMonitor] Found new ROOT_ID: $ROOT_ID - Adding policies..."
                    
                    ADMIN_ID=$(GET_UUID "user-{{ .Values.global.ldap.initialAdminIdentity }}")
                    INGRESS_DN="CN={{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
                    INGRESS_ID=$(GET_UUID "user-$INGRESS_DN")
                    {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                    NODE{{ $i }}_DN="CN={{ include "nifi.fullname" $ }}-{{ $i }}.{{ include "nifi.fullname" $ }}.{{ $.Release.Namespace }}"
                    NODE{{ $i }}_ID=$(GET_UUID "user-$NODE{{ $i }}_DN")
                    {{- end }}
                    
                    # Create policies for ROOT_ID
                    {
                        P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
                        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        echo "      <user identifier=\"$INGRESS_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                        
                        P_ID=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
                        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        echo "      <user identifier=\"$INGRESS_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                        
                        P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
                        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                        
                        P_ID=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
                        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/data/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                        
                        P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
                        echo "    <policy action=\"R\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                        
                        P_ID=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
                        echo "    <policy action=\"W\" identifier=\"$P_ID\" resource=\"/operation/process-groups/$ROOT_ID\">"
                        echo "      <user identifier=\"$ADMIN_ID\"/>"
                        {{- range $i := until (int .Values.global.nifi.nodeCount) }}
                        echo "      <user identifier=\"$NODE{{ $i }}_ID\"/>"
                        {{- end }}
                        echo "    </policy>"
                    } > /tmp/monitor_policies.xml
                    
                    sed -i '/<\/policies>/e cat /tmp/monitor_policies.xml' "$AUTH_XML"
                    rm -f /tmp/monitor_policies.xml
                    echo "[PolicyMonitor] Policies added for ROOT_ID: $ROOT_ID"
                    
                    # Signal NiFi to reload authorizations by touching the file
                    # NiFi's FileAuthorizer watches for file changes
                    touch "$AUTH_XML"
                    
                    # Also try to trigger a reload via the NiFi process
                    # Find NiFi's main Java process and send SIGHUP
                    NIFI_PID=$(pgrep -f "org.apache.nifi.NiFi" | head -1)
                    if [ -n "$NIFI_PID" ]; then
                        echo "[PolicyMonitor] Sending SIGHUP to NiFi (PID: $NIFI_PID) to reload authorizations..."
                        kill -HUP $NIFI_PID 2>/dev/null || true
                    fi
                    
                    echo "[PolicyMonitor] Policies applied. If issues persist, restart pods with: kubectl delete pod -n nifi -l app=nifi"
                else
                    echo "[PolicyMonitor] Policies for ROOT_ID $ROOT_ID already exist."
                fi
            fi
        fi
        
        echo "[PolicyMonitor] Policy monitor completed."
    ) &
    {{- else }}
    # Non-LDAP mode: Create users.xml and authorizations.xml manually
    if [ ! -f "$USERS_XML" ]; then
        echo "Provisioning initial security registry..."
        mkdir -p "$PERSISTENT_CONF_DIR"

        # BUILD IDENTITIES LIST
        ADMIN_IDENTITIES=""
        # NiFi Nodes
        for (( i = 0; i < {{ .Values.global.nifi.nodeCount }}; i++ )); do
            ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}-${i}.{{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        done
        # Ingress Node
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} CN={{ include "nifi.fullname" . }}.{{ .Release.Namespace }}"
        # LDAP Admin
        {{- if and .Values.global.ldap.enabled .Values.global.ldap.initialAdminIdentity }}
        ADMIN_IDENTITIES="${ADMIN_IDENTITIES} {{ .Values.global.ldap.initialAdminIdentity }}"
        {{- end }}

        echo "Identities to authorize:$ADMIN_IDENTITIES"

        # 1. Generate users.xml
        # We'll create a group called 'NiFi Administrators' and add everyone to it.
        # CRITICAL: In NiFi 2.x, <groups> MUST come BEFORE <users> in the <tenants> element.
        GROUP_NAME="NiFi Administrators"
        GROUP_ID=$(GET_UUID "group-$GROUP_NAME")

        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$USERS_XML"
        echo '<tenants>' >> "$USERS_XML"
        echo '  <groups>' >> "$USERS_XML"
        echo "    <group identifier=\"$GROUP_ID\" name=\"$GROUP_NAME\">" >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "      <user identifier=\"$U_ID\"/>" >> "$USERS_XML"
        done
        echo '    </group>' >> "$USERS_XML"
        echo '  </groups>' >> "$USERS_XML"
        echo '  <users>' >> "$USERS_XML"
        for DN in $ADMIN_IDENTITIES; do
            U_ID=$(GET_UUID "user-$DN")
            echo "    <user identifier=\"$U_ID\" identity=\"$DN\"/>" >> "$USERS_XML"
        done
        echo '  </users>' >> "$USERS_XML"
        echo '</tenants>' >> "$USERS_XML"

        # 2. Generate authorizations.xml
        echo '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' > "$AUTH_XML"
        echo '<authorizations>' >> "$AUTH_XML"
        echo '  <policies>' >> "$AUTH_XML"
        
        RESOURCES="/flow /controller /proxy /restricted-components /tenants /policies"
        
        # Access Root Group - Get ROOT_ID from existing flow or wait for it
        ROOT_ID=""
        if [ -s "$FLOW_FILE" ]; then
            ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        fi
        
        # If no flow exists yet, we'll add root group policies after NiFi creates the flow
        # For now, add a placeholder that will be updated on subsequent restarts
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            echo "Found existing ROOT_ID: $ROOT_ID"
            RESOURCES="$RESOURCES /process-groups/$ROOT_ID /data/process-groups/$ROOT_ID /operation/process-groups/$ROOT_ID"
        else
            echo "No flow.json.gz found yet. Root group policies will be added after first NiFi startup."
        fi

        for RES in $RESOURCES; do
            for ACT in R W; do
                P_ID=$(GET_UUID "policy-$RES-$ACT")
                echo "    <policy action=\"$ACT\" identifier=\"$P_ID\" resource=\"$RES\">" >> "$AUTH_XML"
                echo "      <group identifier=\"$GROUP_ID\"/>" >> "$AUTH_XML"
                echo "    </policy>" >> "$AUTH_XML"
            done
        done
        echo '  </policies>' >> "$AUTH_XML"
        echo '</authorizations>' >> "$AUTH_XML"
        echo "Security registry provisioned successfully."
    fi
    {{- end }}

    {{- if not .Values.global.ldap.enabled }}
    # UPDATE ROOT GROUP POLICIES if flow.json.gz exists but policies are missing
    # This handles the case where NiFi created the flow after initial provisioning
    if [ -f "$AUTH_XML" ] && [ -s "$FLOW_FILE" ]; then
        ROOT_ID=$(zcat "$FLOW_FILE" 2>/dev/null | jq -r '.rootGroup.identifier' 2>/dev/null || true)
        if [ -n "$ROOT_ID" ] && [ "$ROOT_ID" != "null" ] && [ "$ROOT_ID" != "true" ]; then
            # Check if root group policies already exist
            if ! grep -q "process-groups/$ROOT_ID" "$AUTH_XML"; then
                echo "Adding missing root group policies for ROOT_ID: $ROOT_ID"
                GROUP_ID=$(GET_UUID "group-NiFi Administrators")
                
                # Generate policy IDs
                P1=$(GET_UUID "policy-/process-groups/$ROOT_ID-R")
                P2=$(GET_UUID "policy-/process-groups/$ROOT_ID-W")
                P3=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-R")
                P4=$(GET_UUID "policy-/data/process-groups/$ROOT_ID-W")
                P5=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-R")
                P6=$(GET_UUID "policy-/operation/process-groups/$ROOT_ID-W")
                
                # Create temporary file with new policies using echo
                echo "    <policy action=\"R\" identifier=\"$P1\" resource=\"/process-groups/$ROOT_ID\">" > /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P2\" resource=\"/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P3\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P4\" resource=\"/data/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"R\" identifier=\"$P5\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                echo "    <policy action=\"W\" identifier=\"$P6\" resource=\"/operation/process-groups/$ROOT_ID\">" >> /tmp/new_policies.xml
                echo "      <group identifier=\"$GROUP_ID\"/>" >> /tmp/new_policies.xml
                echo "    </policy>" >> /tmp/new_policies.xml
                
                # Insert before </policies> using sed with file read
                sed -i '/<\/policies>/e cat /tmp/new_policies.xml' "$AUTH_XML"
                rm -f /tmp/new_policies.xml
                echo "Root group policies added successfully."
            else
                echo "Root group policies already exist for ROOT_ID: $ROOT_ID"
            fi
        fi
    fi
    {{- end }}

    echo "DEBUG: users.xml content:"
    [ -f "$USERS_XML" ] && cat "$USERS_XML" || echo "users.xml NOT FOUND"
    echo "DEBUG: authorizations.xml content:"
    [ -f "$AUTH_XML" ] && cat "$AUTH_XML" || echo "authorizations.xml NOT FOUND"
    echo "DEBUG: Finished registry print."

    {{- if not .Values.global.ldap.enabled }}
    # Update authorizers.xml paths to point to persistent files (only for non-LDAP mode)
    conf_dir='/opt/nifi/nifi-current/persistent_conf'
    sed -i -E "s|(<property name=\"Authorizations File\">).*(</property>)|\1${conf_dir}/authorizations.xml\2|g" "${authorizers_file}"
    sed -i -E "s|(<property name=\"Users File\">).*(</property>)|\1${conf_dir}/users.xml\2|g" "${authorizers_file}"
    {{- else }}
    # authorizers.xml was already created from scratch earlier in LDAP mode
    # No need to modify the default NiFi authorizers.xml file
    echo "LDAP configuration completed with deterministic provisioning."
    {{- end }}

    {{- /* Set file and directory paths to persistent locations */}}
    {{- with .Values.persistence }}
    conf_dir='./persistent_conf'
    prop_replace 'nifi.flow.configuration.file' "${conf_dir}/{{ .config.files.flowJson }}"
    prop_replace 'nifi.flow.configuration.archive.dir' "${conf_dir}/archive"

    # Only update paths if not in LDAP mode (LDAP mode already created authorizers.xml with correct paths)
    {{- if not $.Values.global.ldap.enabled }}
    sed -i -E "s|(<property name=\"Authorizations File\">).*(</property>)|\1${conf_dir}/{{ .config.files.authorizations }}\2|g" "${authorizers_file}"
    sed -i -E "s|(<property name=\"Users File\">).*(</property>)|\1${conf_dir}/{{ .config.files.users }}\2|g" "${authorizers_file}"
    {{- end }}
    {{- end }}

    {{- /* Define flowfile repository */}}
    {{- with .Values.persistence.repo.flowfile }}
    prop_replace 'nifi.flowfile.repository.directory' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define content repositories */}}
    prop_remove 'nifi.content.repository.directory.default'
    {{- range .Values.persistence.repo.content }}
    prop_add 'nifi.content.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define provenance repositories */}}
    prop_remove 'nifi.provenance.repository.directory.default'
    {{- range .Values.persistence.repo.provenance }}
    prop_add 'nifi.provenance.repository.directory.{{ .name }}' {{ printf "./%s" .mountDir | squote }}
    {{- end }}

    {{- /* Define custom nar library path */}}
    prop_add 'nifi.nar.library.directory.custom' {{ .Values.customLibPath | squote }}

    {{- /* Generate a TLS cert for this node from the CSI-provided certificates and private key */}}
    {{- if .Values.global.tls.certificate }}
    cert_dir='/opt/certmanager'
    tls_dir='/opt/tls'
    rm -f $tls_dir/*
    openssl pkcs12 -export \
      -in $cert_dir/tls.crt \
      -inkey $cert_dir/tls.key \
      -CAfile $cert_dir/ca.crt \
      -passout "pass:${KEYSTORE_PASSWORD}" \
      -out $tls_dir/keystore.p12
    keytool -import -noprompt -trustcacerts \
      -file $cert_dir/ca.crt \
      -storepass "${TRUSTSTORE_PASSWORD}" \
      -destkeystore $tls_dir/truststore.p12 \
      -deststoretype pkcs12
    {{- end }}

    {{- /* Task termination period */}}
    prop_replace 'graceful.shutdown.seconds' {{ .Values.shutdown.gracefulShutdownSeconds }} "${bootstrap_file}"

    {{- /* Set UI autorefresh interval */}}
    prop_replace 'nifi.ui.autorefresh.interval' {{ .Values.ui.refreshInterval | squote }}

    {{- with .Values.ui.timeZone }}
    echo 'java.arg.8=-Duser.timezone={{ . }}' >> "${bootstrap_file}"
    {{- end }}

    {{- with .Values.ui.maxThreads }}
    prop_replace 'nifi.web.jetty.threads' {{ . | squote }}
    {{- end }}

    {{- /* Set user logging levels */}}
    {{- range $logger, $level := .Values.logging.levels }}
    xmlstarlet ed --inplace --update "//logger[@name='{{ $logger }}']/@level" --value '{{ $level }}' "${logback_file}"
    {{- end }}

    {{- /* Set user logging max size capping */}}
    {{- range $appender, $size := .Values.logging.totalSizeCap }}
    xmlstarlet ed -L -s '//appender[@name="{{ $appender }}"]/rollingPolicy' -t elem -n 'totalSizeCap' -v '{{ $size }}' "${logback_file}"
    {{- end }}

    {{- range $key, $value := .Values.extraConfig.nifiProperties }}
    prop_replace {{ $key | squote }} {{ $value | quote }}
    {{- end }}

    {{- if .Values.debugStartup }}
    sleep 1000000
    {{- end }}

    {{- with .Values.umask }}
    umask {{ . }}
    {{- end }}

    exec $scripts_dir/start.sh
  pre-stop.sh: |
    #!/bin/bash

    # NiFi toolkit CLI path
    NIFI_CLI="/opt/nifi/nifi-toolkit-current/bin/cli.sh"

    # NiFi Cluster variables (use a proper hostname substitution here)
    NIFI_URL="https://{{ $serviceHostName }}:8443"

    # Log file path (update to your desired destination)
    LOG_FILE="/opt/nifi/nifi-current/logs/k8s-pre-stop.log"

    # Redirect all output (stdout and stderr) to the log file
    exec > >(tee -a "$LOG_FILE") 2>&1

    # Function to get the status of the node
    get_node_status() {
      NODE_ID="$1"
      NODE_STATUS=$($NIFI_CLI nifi get-node --nifiNodeId "$NODE_ID" -u "$NIFI_URL" -ot json | jq -r '.node.status')
      echo "$NODE_STATUS"
    }

    # Retry function for critical steps (like disconnecting or offloading nodes)
    retry_command() {
      local retries=5
      local wait_time=5
      local cmd="$@"
      
      for ((i=1; i<=retries; i++)); do
        eval "$cmd"
        if [ $? -eq 0 ]; then
          return 0
        fi
        echo "$(date): Command failed. Retrying in $wait_time seconds... (Attempt $i/$retries)"
        sleep $wait_time
      done
      
      echo "$(date): Command failed after $retries attempts. Exiting."
      exit 1
    }

    # Get the hostname
    HOSTNAME=$(hostname)
    echo "$(date): Retrieving node information for the hostname: $HOSTNAME..."

    # Retrieve the list of nodes
    NODE_INFO=$($NIFI_CLI nifi get-nodes -u "$NIFI_URL")

    # Check if NODE_INFO is empty (failed retrieval)
    if [ -z "$NODE_INFO" ]; then
      echo "$(date): Failed to retrieve node information. Exiting."
      exit 1
    fi

    # Extract the node ID based on the hostname
    NODE_ID=$(echo "$NODE_INFO" | grep "$HOSTNAME" | awk '{print $2}')

    # Check if the NODE_ID is empty
    if [ -z "$NODE_ID" ]; then
      echo "$(date): Node ID for $HOSTNAME not found. Exiting."
      exit 1
    fi

    echo "$(date): Node ID for $HOSTNAME is $NODE_ID"

    # Get the current node status
    CURRENT_STATUS=$(get_node_status "$NODE_ID")
    echo "$(date): Current node status: $CURRENT_STATUS"

    # Disconnect the current node if it is not already disconnected
    if [ "$CURRENT_STATUS" != "DISCONNECTED" ]; then
      echo "$(date): Disconnecting node $NODE_ID..."
      retry_command "$NIFI_CLI nifi disconnect-node --nifiNodeId $NODE_ID"
      echo "$(date): Node $NODE_ID disconnected."
    else
      echo "$(date): Node $NODE_ID is already disconnected."
    fi

    # Offload the current node if not already offloaded
    if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
      echo "$(date): Offloading node $NODE_ID..."
      retry_command "$NIFI_CLI nifi offload-node --nifiNodeId $NODE_ID --connectionTimeout 60000 --readTimeout 60000 -u $NIFI_URL"
      echo "$(date): Node $NODE_ID offloading..."
    else
      echo "$(date): Node $NODE_ID is already offloaded."
    fi

    # Wait for the node to be fully offloaded with a retry limit
    MAX_ATTEMPTS=12  # Limit the retries to 12 (with 5-second interval = 1 minute total)
    attempt=1
    while [ $attempt -le $MAX_ATTEMPTS ]; do
      CURRENT_STATUS=$(get_node_status "$NODE_ID")
      if [ "$CURRENT_STATUS" == "OFFLOADED" ]; then
        echo "$(date): Node $NODE_ID successfully offloaded."
        break
      else
        echo "$(date): Current node status: $CURRENT_STATUS. Retrying in 5 seconds... (Attempt $attempt/$MAX_ATTEMPTS)"
        attempt=$((attempt+1))
        sleep 5
      fi
    done

    # If the node hasn't offloaded after the max attempts, exit with an error
    CURRENT_STATUS=$(get_node_status "$NODE_ID")
    if [ "$CURRENT_STATUS" != "OFFLOADED" ]; then
      echo "$(date): Node $NODE_ID failed to offload after $MAX_ATTEMPTS attempts. Exiting."
      exit 1
    fi

    # Remove the node
    echo "$(date): Removing node $NODE_ID..."
    retry_command "$NIFI_CLI nifi delete-node --nifiNodeId $NODE_ID -u $NIFI_URL"
    echo "$(date): Node $NODE_ID offloaded and removed successfully."


{{- with .Values.filebeat }}
{{- if .enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "nifi.fullname" $ }}-filebeat
  labels:
    {{- include "nifi.labels" $ | nindent 4 }}
data:
  filebeat.yml: |
    tags:
      {{- toYaml .tags | nindent 6 }}
    filebeat.inputs:
      - type: filestream
        id: nifi-app
        fields:
          log_id: app
        paths: ["/nifi/logs/nifi-app*.log"]
      - type: filestream
        id: nifi-request
        fields:
          log_id: request
        paths: ["/nifi/logs/nifi-request*.log"]
      - type: filestream
        id: nifi-user
        fields:
          log_id: user
        paths: ["/nifi/logs/nifi-user*.log"]
    {{- if or .labels .processors }}
    processors:
      {{- if .labels }}
      - add_labels:
          labels:
            {{- toYaml .labels | nindent 12 }}
      {{- end }}
      {{- toYaml .processors | nindent 6 }}
    {{- end }}
    {{ printf "output.%s:" .output.type }}
    {{- toYaml .output.parameters | nindent 6 }}
    queue.mem:
      flush.timeout: {{ .queue.flushTimeout }}
{{- end }}
{{- end }}
